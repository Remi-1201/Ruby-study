# Ruby技術者認定試験Silver模擬問題

[回答](silver_answers_ja.md)

**Q1. Rubyにおける真の値として正しいものをすべて選んでください。(2つ選択)**

- (a) `""` 
- (b) `0` 
- (c) `false`
- (d) `nil`

**A1:** (a)および(b)

Rubyではすべてのオブェクトが条件分岐で使用するための論理値を持ちます。

`false`と`nil`は論理的に偽として、それ以外のすべてのオブジェクトは論理的に真として扱われます。

-------------------------------------------------------------------------

**Q2. Rubyの予約語として正しいものをすべて選んでください。(2つ選択)**

- (a) `each`
- (b) `rand`
- (c) `class`
- (d) `send`
- (e) `true`

**A2:** (c)および(e)

Ruby 3.1の予約語の一覧は以下のとおりです。

![Ruby keywords](ruby-keywords.png)

---------------------------------------------------------------------------

**Q3. Rubyの変数名として正しいものを選んでください。(1つ選択)**

- (a) `3y`
- (b) `false`
- (c) `_9class`
- (e) `xyz$`

**A3:** (c)

Rubyのローカル変数名は小文字またはアンダースコアではじまり、アルファベット、数字、アンダースコア、非ASCII文字のみからなります。

予約語を変数名として使用することはできません(例えば`class`という変数名は使用できません)が、予約語を含む変数名は許可されています(つまり`classy`や`_class`は有効な変数名です)。

---------------------------------------------------------------------------

**Q4. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
$code = "CODE"
__(1)__

[出力]
i like writing CODE
```

- (a) `puts "i like writing #{$code}"`
- (b) `puts "i like writing #$code"`
- (c) `puts 'i like writing #{$code}'`
- (d) `puts 'i like writing #$code'`

**A4:** (a)および(b)

シングルクォートの文字列リテラルはシンプルで、文字のそのままの列を表現します。

ダブルクォートの文字列リテラルはより複雑ですが、Rubyの式の評価結果を文字列中に埋め込む式展開(`#{...}`)のような機能を提供します。

グローバル変数の値を埋め込む場合は`#$`を省略記法として使用できます(同様にインスタンス変数の場合は`#@`を使用できます)。この省略記法はより一般的な`#{...}`記法に比べるとあまり使われていません。

---------------------------------------------------------------------------

**Q5. 以下のコードがあります。** 

```
num = 025
puts num
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `nil`
- (b) `025`
- (c) `21`
- (d) `25`

**A5:** (c)

整数リテラルの先頭の0は8進数表記を意味します。ただし、デフォルトでは10進数として出力が行われます。

10進数以外での出力を行うためには、さまざまな書式化数値出力機能が提供されています(例: `Strign#%`、`Numeric#to_s(base)`、`Kernel#printf`)。

---------------------------------------------------------------------------

**Q6. 以下のコードがあります。**

```
x = "Hello"
y = x.empty? ? 1 : 2
p y
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) 1
- (b) 2
- (c) "Hello"
- (d) true

**A6:** (b)

三項演算子(`cond ? expr1 : expr2`)は`if/else`の省略形で、`cond`が真の場合`expr1`を、偽の場合`expr2`を返します。1行に収まるような短い文の記述に向いています。

---------------------------------------------------------------------------

**Q7. 以下のコードがあります。**

```
amount = 120

size = case amount
  when 1..120; "S"
  when 120..170; "M"
  when 170..200; "L"
  else "XL"
end

p size
```

- (a) `"S"`
- (b) `"M"`
- (c) `"L"`
- (d) `"XL"`

**実行結果として正しいものを選択してください。(1つ選択)**

**A7:** (a)

`case`文は`when`の条件にマッチする最初の分岐を実行します。

Rubyの範囲リテラル`x..y`は、`y`の値を含みます。

したがって、`1..120`と`120..170`の両方が`120`を含み、`when 1..120`の分岐が最初にマッチして実行されます。

---------------------------------------------------------------------------

**Q8. 以下のコードがあります。**

```
item = "apple"

["banana", "carrot", "daikon"].each do |item|
  puts item
end

puts item
```

**実行結果として正しいものを選択してください。(1つ選択)**

*(a)*
文法エラーが発生する

*(b)*
例外が発生する

*(c)*
```
banana
carrot
daikon
daikon
```

*(d)*
```
banana
carrot
daikon
apple
```

**A8:** (d)

ブロックでは外側のスコープのローカル変数にアクセスすることができますが、ブロックパラメータ自体は常にブロックローカルです。これはブロックパラメータの名前が外側のローカル変数と同じ場合、ブロック内ではブロックローカル変数が参照されることを意味します。これによって、変数名が衝突した場合に外側のローカル変数を誤って変更することが防がれます。

外側のローカル変数と同名のブロックパラメータを定義することはアンチパターンと考えられ、プログラムの間違いのサインかもしれません。この問題を発見するには、`ruby`を`-w`オプション付きで実行し、`warning: shadowing outer local variable - item`のような警告を表示させるようにします。

---------------------------------------------------------------------------

**Q9. 以下のコードがあります。**

```
x = 0

4.times do |i|
  x += i
end

p x
```

**実行結果として正しいものを選択してください。(1つ選択)**


- (a) `0`
- (b) `4`
- (c) `6`
- (d) 文法エラーが発生する

**A9:** (c)

`Integer#times`メソッドは0から指定された値より1つ小さい整数までの値を順番にブロックパラメータとして渡します。

ブロックパラメータと同名の外側のローカル変数は参照できません(A8参照)が、他のローカル変数はアクセス・変更できます。これはRubyのブロックはクロージャであるためです。

---------------------------------------------------------------------------

**Q10. 以下のコードがあります。**

```
s = "abcde"
p s.each_char.map { |i|
  i * 2
}
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `[97, 98, 99, 100, 101]`
- (b) `[194, 196, 198, 200, 202]`
- (c) `["a", "b", "c", "d", "e"]`
- (d) `["aa", "bb", "cc", "dd", "ee"]`
- (e) 実行時にエラーになる

**A10:** (d)

[String#each_char](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_EACH_CHAR)はレシーバのそれぞれの文字をyieldする[Enumerator](https://docs.ruby-lang.org/en/3.1/Enumerator.html)を返します。文字は1文字のも文字列で表現されることに注意してください。

[Enumerable#map](https://docs.ruby-lang.org/ja/3.1/class/Enumerable.html#I_MAP) は与えられたブロックの値の配列を返します。

`string * integer`は`string`を`integer`回コピーして連結した値を返します。

したがって、`s.each_char.map { |i| i * 2}`の評価結果は`["aa", "bb", "cc", "dd", "ee"]`になります。

---------------------------------------------------------------------------

**Q11. 以下のコードがあります。**

```
p "cocoa".chars.tally
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `{99=>2, 111=>2, 97=>1}`
- (b) `{?c=>2, ?o=>2, ?a=>1}`
- (c) `{"c"=>2, "o"=>2, "a"=>1}`
- (d) 実行時にエラーになる

**A11:** (c)

[String#chars](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_CHARS)はレシーバのすべての文字の配列を返します。文字は1文字のも文字列で表現されることに注意してください。

[Enumerable#tally](https://docs.ruby-lang.org/ja/3.1/class/Enumerable.html#I_TALLY)は値が同じ要素の数を含むハッシュを返します。

したがって、`"cocoa".chars.tally`の評価結果は`{"c"=>2, "o"=>2, "a"=>1}`になります。

---------------------------------------------------------------------------

**Q12. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)** 

```
puts "blah blah blah".__(1)__(/blah/, "yay")

[出力]
yay yay yay
```

- (a) `sub`
- (b) `gsub`
- (c) `replace`
- (d) `replace_all`

**A12:** (b)

[String#gsub](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_GSUB)はパターンにマッチするすべての部分を置換した文字列を返します。


[String#sub](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_SUB)はパターンにマッチする最初の部分を置換した文字列を返します。

[String#replace](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_REPLACE) は与えられた文字列でレシーバの内容を置き換えます。

Stringに`#replace_all`メソッドはありません。

---------------------------------------------------------------------------

**Q13. 以下のコードがあります。**

```
s = "pear"

if s.empty?
  puts "blank"
elsif s.length < 5
  puts "short"
else
  puts "long"
end
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) blank
- (b) short
- (c) long
- (d) 例外が発生する

**A13:** (b)

`if/elsif/else`文では、最初に条件を満たした`if`または`elsif`の分岐が実行されます。いずれも条件を満たさない場合は、`else`の分岐が実行されます。

---------------------------------------------------------------------------

**Q14: 以下のコードがあります。**

```
["foo: abc", "bar: 100"].each do |i|
  p i.slice(/[0-9]+/)&.to_i
end
```

**実行結果として正しいものを選択してください。(1つ選択)**

*(a)*
```
0
100
```

*(b)*
```
nil
100
```

*(c)*
```
false
100
```

*(d)*
文法エラーが発生する

*(e)*
実行時にエラーになる

**A14:** (b)

[String#slice](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_SLICE)は最初にマッチした部分文字列を返します。マッチしなかった場合は`nil`を返します。
`x&.foo`は`x`が`nil`でない場合`x`に対して`foo`メソッドを呼び出します。`x`が`nil`の場合、`x&.foo`はメソッドを呼び出さず、`nil`を返します。

---------------------------------------------------------------------------

**Q15: 以下のコードがあります。**

```
def foo(x: 1, y: 2, z: 3)
  p [x, y, z]
end

foo(y: 4, z: 5)
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `[1, 2, 3]`
- (b) `[1, 4, 5]`
- (c) 文法エラーが発生する
- (d) 実行時にエラーになる

**A15: (b)**

キーワード引数が与えられなかった場合、メソッド定義のデフォルト値が使用されます。
 
---------------------------------------------------------------------------

**Q16: 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)** 

```
def foo(x:, y:, z:)
  p [x, y, z]
end

h = {x: 1, y: 2, z: 3}
__(1)__
[出力]
[1, 2, 3]
```

- (a) `foo(*h)`
- (b) `foo(**h)`
- (c) `foo(&h)`
- (d) `foo(^h)`

**A16: (b)**

`**` はHashをキーワード引数に変換します。

---------------------------------------------------------------------------

**Q17. "Ruby"または"ruby"のいずれかの文字列のみにマッチする正規表現をすべて選択してください。(2つ選択)**

- (a) `/\A[Rr]uby\z/`
- (b) `/\ARuby|ruby\z/`
- (c) `/\A[Rr][u][b][y]\z/`
- (d) `/\AR|ruby\z/`

**A17: (a)および(c)**

文字クラス(`[...]`)はブラケット内のいずれかの文字にマッチします。

選択(`...|...`)は複数の部分式のいずれかにマッチします。

`\A`アンカーは文字列の先頭に、`\z`アンカーは文字列の末尾にマッチします。

(b)が正解でないのは、(b)の部分式は`\ARuby`と`ruby\z`であり、`Ruby123`のような文字列にもマッチしてしまうためです。

---------------------------------------------------------------------------

**Q18.以下のコードがあります。**

```
MSG = 42
MSG += 5
p MSG
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) 警告なしで`47`が表示される。
- (b) MSGは定数なのでエラーが発生する。
- (c) MSGは定数なので`42`が表示される。
- (d) MSGは定数なので警告が表示されるが、`47`が表示される。

**A18: (d)**

定数は再定義できますが、通常あまり好ましくないため、警告が表示されます。

Rubyでは定数はモジュールやクラスの名前にも使用されるため、定数の再定義に関する警告は意図しない名前の衝突を防ぐために有用です。

---------------------------------------------------------------------------

**Q19. 以下のコードがあります。**

```
MSG = "hello"
MSG.upcase!
p MSG
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) MSGは定数なのでエラーが発生する。
- (b) 警告なしで`HELLO`が表示される。
- (c) MSGは定数なので警告が表示されるが、`HELLO`が表示される。
- (d) MSGは定数なので`hello`が表示される。

**A19: (b)**

定数は再定義されず、定数から参照されるオブジェクトの内容が変更されているだけなので、警告は表示されません。

慣習的に定数から参照されるオブジェクトは変更されないものとして扱われますが、その慣習があてはまらないレアケースもあります。

---------------------------------------------------------------------------

**Q20. 以下の説明のうち正しいものをすべて選択してください。(2つ選択)**

- (a) ローカル変数は小文字ではじまり、2文字以上の長さである。
- (b) グローバル変数は$ではじまる。
- (c) インスタンス変数は*ではじまる。
- (d) クラス変数は$ではじまる。
- (e) 定数は大文字ではじまる。

**A20: (b)および(e)**

Rubyの変数名についてのルールは以下のとおりです。

- グローバル変数は`$`ではじまります。
- クラス変数は`@@`ではじまります。
- インスタンス変数は`@`ではじまります。
- ローカル変数は小文字またはアンダースコアではじまります。
- 残りの文字はアルファベット、数字、アンダースコア、非ASCII文字に限定されます。

---------------------------------------------------------------------------

**Q21. 以下のコードがあります。**

```
x = [1,2,3,4,5,6,7,8]
y = x
x.reject! { |e| e.even? }
p x
p y
```

**実行結果として正しいものを選択してください。(1つ選択)**


*(a)*
```
[1, 3, 5, 7]
[1, 2, 3, 4, 5, 6, 7, 8]
```

*(b)*
```
[1, 2, 3, 4, 5, 6, 7, 8]
[1, 2, 3, 4, 5, 6, 7, 8]
```

*(c)*
```
[1, 3, 5, 7]
[1, 3, 5, 7]
```

*(d)*
```
[1, 3, 5, 7]
[2, 4, 6, 8]
```

**A21: (c)** 

この例では、`x`と`y`は両方とも同じ配列オブジェクトを参照します。

`Array#reject!`はレシーバを変更するため、両方の変数から参照される一つの配列が変更が変更されるということを意味します。

---------------------------------------------------------------------------

**Q22. 以下のコードがあります。**

```
a = [ 2, 4, 6, 8, 10 ]
a.shift
a.pop
a.push(12)
p a
```

- (a) `[2, 4, 6, 8, 10, 12]`
- (b) `[2, 4, 6, 8, 10]`
- (c) `[4, 6, 8, 12]`
- (d) `[4, 6, 8]`

**実行結果として正しいものを選択してください。(1つ選択)**

**A22: (c)**

以下のような配列操作があります。

- `shift`は配列の最初の要素を削除し、その要素を返します。
- `pop`は配列の最後の要素を削除し、その要素を返します。
- `push`は配列の末尾に指定された要素を追加します。

---------------------------------------------------------------------------

**Q23. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)** 

```
x = true
x __(1)__ exit(1)
puts("succeeded!")

[出力]
succeeded!
```


- (a) `|`
- (b) `||`
- (c) `&`
- (d) `&&`

**A23: (b)**

論理演算子`||`と`&&`は短絡評価され、必要な場合だけ右辺が評価されます。

真理値オブジェクトのために`|`と`&`が提供されており、これらは短絡評価を行わず、常に右辺が評価されます。

`||`と`&&`はすべてのオブジェクトに対して使用できますが、`|`と`&`は実装されていないオブジェクトもあることに注意してください

---------------------------------------------------------------------------

**Q24. 以下のコードがあります。**

```
m = true
m or n = true
p n
```

**実行結果として正しいものを選択してください。(1つ選択)**


- (a) `true`
- (b) `false`
- (c) `nil`
- (d) 文法エラーが発生する

**A24: (c)**

`or`演算子は短絡評価され`n = true`という式は実行されませんが、ローカル変数`n`は静的に宣言されます。したがって、変数は存在しますが、その値は`nil`です。

---------------------------------------------------------------------------

**Q25. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
x = [ 9, 7, 5, 3, 1 ]
p __(1)__

[出力]
[7, 5, 3]
```

- (a) `x[1, 3]`
- (b) `x[1..-1]`
- (c) `x[-3..-1]`
- (d) `x[-4..-2]`

**A25: (a)および(d)**

この問題では部分配列を指定する二つの異なる方法を示しています。

一つのアプローチは二つの整数を使用する方法、つまり`x[1,3]`のような書き方で、これはインデックス`1`からはじまる長さ`3`の部分配列を意味します。

Another approach is to use a range, which generates a subarray based the index values within that range.
もう一つのアプローチはRangeオブジェクトを使用する方法で、指定された範囲に含まれるインデックスの値にもとづいた部分配列を生成します。

範囲を使うシンプルな形式は`x[1..3]`のようなもので、インデックス`1`ではじまり`3`で終わる部分配列を返します。

しかし、Rubyでは負のインデックスも許可されており、配列の先頭からではなく末尾からのインデックスとして使用されます。

したがって、`x[-4..-2]`は配列の末尾から4番目から末尾から2番目までの部分配列を返します。

インデックスの意味を明確にするため、この問題の配列の各要素に対応するインデックスの値を以下に示します。

```
 x  [ 9,   7,   5,    3,    1]
 i    0    1    2     3     4
-i   -5   -4   -3    -2    -1
```

---------------------------------------------------------------------------

**Q26. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
ary = [ 1, 2, 3, 4, 5 ]
p ary.__(1)__ { |i| i.odd? }

[出力]
[1, 3, 5]
```

- (a) `collect`
- (b) `select`
- (c) `map`
- (d) `filter`
- (e) `filter_map`

**A26: (b)および(d)**

`Array#select`と`Array#filter`は与えられたブロックが真の値を返す要素の配列を返します。

---------------------------------------------------------------------------

**Q27. 以下のコードがあります。**

```
puts "42A7".to_i
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) 42
- (b) 42A7
- (c) 17063
- (d) 実行時にエラーになる

**A27: (a)**

`String#to_i`は先頭の文字から整数としての解析を試み、指定された基数で有効な数字ではなくなるまで解析を続けます。文字列が有効な数字ではじまらない場合、`0`が返されます。

デフォルトでは10進数として解析されますが、他の基数(`2`から`36`まで)をパラメータで指定することができます。

`A`は10進数の一部として有効でないため`"42A7".to_i`は`42`を返しますが、`"42A7".to_i(16)`は16進数`0x42A7`の値(10進数では`17063`)を返すことに注意してください。

---------------------------------------------------------------------------

**Q28. 次のメソッドのうち`:c`がハッシュのキーとして存在するかどうかを「返さない」ものを選択してください。(1つ選択)**

```
h = {a: 2, b: 4, c: 6, d: 8, e: 10}
```

- (a) `p h.has_key?(:c)`
- (b) `p h.contain?(:c)`
- (c) `p h.include?(:c)`
- (d) `p h.key?(:c)`
- (e) `p h.member?(:c)`

**A28. (b)**

`has_key?`、`include?`、`key?`、`member?`はすべて同じメソッドの別名で、与えられたキーがハッシュに存在する場合`true`を、存在しない場合`false`を返します。

`Hash`に`contain?`メソッドはありません。

---------------------------------------------------------------------------

**Q29. "以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
a = [120, 40, 20, 80, 160, 60, 180]
a.__(1)__
p a

[出力]
[120, 80, 160, 180]
```

- (a) `reject! {|i| i < 80}`
- (b) `slice {|i| i < 80 }`
- (c) `slice! {|i| i < 80}`
- (d) `delete_if! {|i| i < 80}`
- (e) `delete_if {|i| i < 80}`
- (f) `reject {|i| i < 80}`

**A29: (a)および(e)**

配列の操作に関する注意事項です。

- `reject!`に加えて`reject`もあり、元の配列を変更する代りに新しい配列を返します。
- `delete_if`の非破壊的バージョンはないため、`delete_if!`というメソッドはありません。Rubyでは似た機能のうち片方がより危険である場合にだけメソッド名の末尾に`!`を付けます。
- `Array#slice`は`Array#[]`の別名で、条件によるフィルタリングを行うのではなく、インデックスにより特定の要素や部分配列を返します。`Array#slice`はブロックを取りません。

---------------------------------------------------------------------------

**Q30. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)**

```
p ["apple", "banana"] __(1)__ ["banana", "carrot"]

[出力]
["apple", "banana", "carrot"]
```

- (a) `.concat`
- (b) `&`
- (c) `|`
- (d) `||`

**A30: (c)**

`|`演算子は和集合に相当します。二つの配列を重複を除去して結合し、元の順序を保持した新しい配列を返します。

---------------------------------------------------------------------------

**Q31. 以下のコードがあります。**

```
p %i(x1 x2 x3)
```

実行結果として正しいものを選択してください。(1つ選択)

- (a) `"x1 x2 x3"`
- (b) `[1, 2, 3]`
- (c) `["x1", "x2", "x3"]`
- (d) `[:x1, :x2, :x3]`

**A31: (d)**

`%i(...)`は式展開を行わずにシンボルの配列を返します。シンボルは空白で区切られます。

詳細は[%記法のドキュメント](https://docs.ruby-lang.org/ja/3.1/doc/spec=2fliteral.html#percent)を参照してください。

---------------------------------------------------------------------------

**Q32. 以下のコードがあります。**

```
class SomeError < StandardError; end
class SomeOtherError < SomeError; end

def meth1
  raise SomeOtherError.new("error")
end

begin
  meth1
rescue SomeError
  print "SomeError"
rescue SomeOtherError
  print "SomeOtherError"
end
```

実行結果として正しいものを選択してください。(1つ選択)

- (a) A syntax error
- (b) `SomeError`
- (c) `SomeErrorSomeOtherError`
- (d) `SomeOtherError`

**A32: (b)**

`begin/rescue/end`では最初に該当した`rescue`節が実行されます。

`SomeOtherError`は`SomeError`のサブクラスなので、`rescue SomeError`節が該当して実行されます。

現実のアプリケーションでは、一般的なエラーよりも特定的なエラーから順に`rescue`するのがよい習慣です(例えば、`rescue StandardError`は最後に記述します)。

---------------------------------------------------------------------------

**Q33. 以下のコードがあります。**

```
begin
  ans = 100/0
  puts ans
rescue ZeroDivisionError
  puts "Error: ZeroDivisionError"
  exit 1
ensure
  puts "DONE!"
end
```

**実行結果として正しいものを選択してください。(1つ選択)**

*(a)*
```
0
DONE!
```

*(b)*

```
Error: ZeroDivisionError
```

*(c)*
```
Error: ZeroDivisionError
DONE!
```

*(d)*
```
Error: ZeroDivisionError
0
```

**A33: (c)**

0による除算で`ZeroDivisionError`が発生します。

`ZeroDivisionError`が補足され、メッセージが出力されます。`exit(1)`はエラーコードとともにプログラムの実行を終了します。

しかし、`begin...end`に`ensure`節があるため、インタープリタの終了前に`ensure`節が実行されます。

`ensure`節は、例外が発生したりRubyが終了した時にも後始末を行うことができるため、便利です。ファイルハンドルやデータベース接続のクローズなどに利用されます。

---------------------------------------------------------------------------

**Q34. Rubyのクラスの説明として正しいものを選択してください。(1つ選択)**

クラスのスーパークラスを明示的に指定しなかった場合、

- (a) 例外`UndefinedParentClassError`が発生する
- (b) 文法エラーが発生する
- (c) `Module`クラスがスーパークラスになる
- (d) スーパークラスのないクラスが作成される
- (e) `Object`クラスがスーパークラスになる

**A34: (e)** 

デフォルトでは、明示的にスーパークラスを指定してもしなくても、すべてのクラスは`Object`を継承します。

`Object`を継承しないクラス階層を構築するには、代りに`BasicObject`を継承することができます。`BasicObject`は非常に少ない機能しか備えておらず、通常のユースケースでは`BasicObject`を直接継承する必要はありません。

---------------------------------------------------------------------------

**Q35. 以下のコードがあります。**

```
class Object
  def moo
    puts "MOO!"
  end
end

"Cow".moo
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) 何も出力されない
- (b) 実行時にエラーになる
- (c) `MOO!`
- (d) `nil`

**A35: (c)**

クラス定義はいつでも再オープンして更新することができます。`Object`のような組み込みクラスの場合も同様です。

すべての組み込みクラス(ただし`BasicObject`は除く)は`Object`を継承しているため、`Object`にメソッドを追加するとすべてのオブジェクトで利用できます。

---------------------------------------------------------------------------

**Q36. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)** 

```
class Shouter
  def __(1)__(message)
    @message = message
  end

  def greet
    puts @message.upcase
  end
end

g = Shouter.new("Hello, world!")
g.greet

[出力]
HELLO, WORLD!
```

- (a) `Shouter`
- (b) `new`
- (c) `initialize`
- (d) `__init__`

**A36: (c)**

クラスに対して`new`メソッドが呼ばれると、そのクラスのインスタンスが生成され、そのインスタンスに対して`initialize`が呼ばれます。この動作によりインスタンス生成時の初期化が可能になっています。

---------------------------------------------------------------------------

**Q37. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)** 

```
class Shouter
  def initialize(message)
    @message = message
  end

  def greet
    puts @message.upcase
  end
end

g = __(1)__("Hello, world!")
g.greet

[出力]
HELLO, WORLD!
```

- (a) `Shouter`
- (b) `#Shouter`
- (c) `new Shouter`
- (d) `Shouter.new`

**A37: (d)**

`Class`に定義されている`new`メソッドは新しいインスタンスの作成に使用されます。

---------------------------------------------------------------------------

**Q38. 以下のコードがあります。**

```
class Foo
  attr_reader :var
  def initialize
    @var = "apple"
  end
end

class Bar < Foo
  def initialize
    @var = "banana"
    super
  end
end

bar = Bar.new
puts bar.var
```

**実行結果として正しいものを選択してください。(1つ選択)**


- (a) apple
- (b) banana
- (c) 何も出力されない
- (d) 実行時にエラーになる

**A38: (a)**

予約語`super`は継承ツリーの祖先の同名のメソッドを呼びます。

この例では、`Bar.new`によって`Bar#initialize`が呼ばれ、`@var = "banana"`の代入が実行されます。しかしその直後に`super`によって`Foo#initialize`が呼ばれて`@var = apple"`の代入が実行されるため、最終的に`apple`が出力されます。

---------------------------------------------------------------------------

**Q39. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)**

```
puts "$foo$".__(1)__("$")

[出力]
foo$
```

- (a) `sub`
- (b) `chop`
- (c) `delete`
- (d) `delete_prefix`


**A39: (d)**

[String#delete_prefix](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_DELETE_PREFIX)は与えられた文字列を先頭から削除した文字列を返します。

[String#delete](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_DELETE)は引数で指定されたすべての文字を削除するため、`"$foo$".delete("$")`の評価結果は`"foo"`になります。


[String#sub](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_SUB)は2つの引数を取り、[String#chop](https://docs.ruby-lang.org/ja/3.1/class/String.html#I_CHOP)は引数を取らないため、`sub("$")`と`chop("$")`はArgumentErrorになります。

---------------------------------------------------------------------------

**Q40. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(1つ選択)**

```
r = "a".."e"
p r.__(1)__

[出力]
["a", "b", "c", "d", "e"]
```

- (a) `array`
- (b) `to_ary`
- (c) `to_a`
- (d) `to_array`


**A40: (c)**

`to_a`という名前のメソッドは慣習的にオブジェクトを配列に変換するために使用され、Rubyのコレクションクラスで利用可能です。

いくつかのオブジェクトでは`to_ary`も実装され、暗黙的な配列への変換に使用されます。例えば、`Array#flatten`はそれぞれの要素に対して`to_ary`の呼び出しを試みます。しかし、通常のユースケースでは`to_ary`はあまり使用されません。

---------------------------------------------------------------------------

**Q41. 以下のコードがあります。**

```
p [0,1,2,3,4,5].find {|x| x < 3}
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `[0, 1, 2]` 
- (b) `0`
- (c) `[0, 1, 2, 3]`
- (d) `true`

**A41: (b)**

`#find`メソッドは`Enumerable`モジュールに定義されており、ブロックの値が真になる最初の要素を返します。

`Enumerable#find`には`Enumerable#detect`という別名があることに注意してください。

---------------------------------------------------------------------------

**Q42. 以下の実行結果を出力するコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
p [1,16,8,4,2].__(1)__

[出力]
[16, 8, 4, 2, 1]
```


- (a) `sort_by { |x| -x }`
- (b) `sort_reverse`
- (c) `sort.reverse`
- (d) `reverse.sort`

**A42: (a)および(c)**

`sort_by`メソッドはコレクションの要素に対してブロックの値を対応付け、ブロックの値の昇順で要素をソートします。

`sort`メソッドは(ブロックがない場合)要素を昇順にソートします。ブロックを与えると要素をブロックで比較してソートすることができます。

`sort_by`も`sort`もオブジェクトを`<=>`演算子で比較できることに依存しています。Rubyの数値クラスはすべて`<=>`演算子を実装していますが、自分は作成したクラスに定義することもできます。

---------------------------------------------------------------------------

**Q43. 配列を降順にソートするコードがあります。
__(1)__に入る適切な記述を選択してください。(2つ選択)** 

```
ary = [2,4,8,1,16]
p ary.__(1)__

[出力]
[16, 8, 4, 2, 1]
```

- (a) `sort { |i,j| -i <= -j }`
- (b) `sort { |i,j| -i <=> -j }`
- (c) `sort { |i,j| i >= j }`
- (d) `sort{ |i,j| i <=> j }`

**A43: (b)**

`sort`メソッドにブロックを与えると、要素をブロックで比較してソートします。

ブロックでは二つの要素の比較を行い、最初の要素の順序が前の場合は負の値を、二つの要素の順序が同じ場合は0を、最初の要素の順序が後の場合は正の値を返す必要があります。

Rubyの数値クラスの`<=>`の動作は、この挙動を自動的に提供します。

```
>> 3 <=> 1
=> 1
>> 3 <=> 3
=> 0
>> 3 <=> 5
=> -1
```

`<=>`(UFO演算子)は意味のあるソート順序をもつ任意のオブジェクトに実装可能です。

---------------------------------------------------------------------------

**Q44. 以下のコードがあります。**

```
File.write("test", "hellorubyworld\n")
File.open("test") do |file|
  file.seek(5)
  print file.gets
end
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) hello
- (b) rubyworld
- (c) hellor
- (d) rubyw
- (e) orubyworld

**A44: (b)**

The `seek` method is used to move to a specific byte offset in an I/O stream.
Offsets are zero-based, so `seek(5)` sets the position in the stream to just *after* the fifth byte.
`seek`メソッドはI/Oストリームの特定のバイトオフセットに移動するために使用されます。
オフセットは0ベースで、`seek(5)`は5バイト目の直後の位置にセットします。

`gets`メソッドはストリームの現在の位置から行の終端まで読み込みます。

---------------------------------------------------------------------------

**Q45. 以下のコードではopenメソッドの第2引数を省略してファイルを開いています。このケースで暗黙的に第2引数として指定されるものを選択してください。**

```
file = open("sample.txt")
```

- (a) `r`
- (b) `r+`
- (c) `a`
- (d) `a+`
- (e) `w`
- (f) `w+`

**A45: (a)**

`"r"`オープンモードは「ファイルの先頭から読み込みのみ」を意味します。

これはデフォルトの挙動として安全で、もっとも一般的なユースケースです。

---------------------------------------------------------------------------

**Q46: test_one.txtの内容をtest_two.txtにコピーするコードがあります。
__(1)__に入る適切な記述を選択してください。**

**test_two.txtがすでに存在する場合、このコードは最初にファイルサイズを0にし、先頭から内容を上書きするものとします。(2つ選択)**

```
open("test_one.txt") {|source|
  open("test_two.txt", "__(1)__") {|dest|
    dest.write(source.read)
  }
}
```

- (a) `r+`
- (b) `a`
- (c) `a+`
- (d) `w`
- (e) `w+`

**A46: (d)および(e)**

Rubyでは以下のI/Oオープンモードがサポ一トされています。

```
"r"  ファイルの先頭から読み込みのみ(デフォルトのモード)

"r+" ファイルの先頭から読み書き可能

"w"  既存のファイルを0バイトに切り詰めるか新しくファイルを作成し、書き込みのみ

"w+" 既存のファイルを0バイトに切り詰めるか新しくファイルを作成し、読み書き可能

"a"  存在しなければ新しくファイルを作成し、ファイル末尾に追記。書き込みのみ

"a+" 存在しなければ新しくファイルを作成し、ファイル末尾に追記。読み書き可能
```

---------------------------------------------------------------------------

**Q47: `Dir`クラスに存在しないクラスメソッドを選択してください。(2つ選択)**

- (a) `Dir.pwd`
- (b) `Dir.rename`
- (c) `Dir.basename`
- (d) `Dir.chdir`
- (e) `Dir.delete`

**A47: (b)および(c)**

補足説明:

fileutils標準ライブラリの`FileUtils.mv`はディレクトリの名前変更に使用できます。

`File.basename`はパスの末尾のファイル名を取得するのに使用されます(例: `File.basename("long/path/to/something") #=> "something"`)。

---------------------------------------------------------------------------

**Q48. 以下のコードがあります。**

```
p "hello ruby world"[6,4]
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `"hello "`
- (b) `"ruby"`
- (c) `" world"`
- (d) 実行時にエラーになる

**A48:** (b)

部分配列のインデックスの指定方法(Q25)と同様に、開始位置と長さを指定して部分文字列を取得することができます。

インデックスはバイト単位ではなく文字(コードポイント)単位であることに注意してください。

---------------------------------------------------------------------------

**Q49:** 

以下のコードがあります。

```
str = "bat"
str[1,1] = "o"
p str
```

実行結果として正しいものを選択してください。(1つ選択)

- (a) `"boo"`
- (b) `"bot"`
- (c) `"oat"`
- (d) `"o"`

**A49: (b)**

置換文字列の長さは元の部分文字列の長さと同じでなくともよいことに注意してください。例えば以下のような操作が可能です。

```
>> str = "boat"
=> "boat"
>> str[1,2] = "uil"
=> "uil"
>> str
=> "built"
```

---------------------------------------------------------------------------

**Q50. 以下のコードがあります。**

```
puts 5 * "hi"
```

**実行結果として正しいものを選択してください。(1つ選択)**

- (a) `"hihihihihi"`
- (b) 実行時にエラーになる
- (c) `"5hi"`
- (d) `"5*hi"`

**A50: (b)**

Rubyの数値クラスでは算術演算の時にオブジェクトを同じ型に変換する`coerce`メソッドが定義されています。このメソッドは`String`クラスでは定義されていないため、`TypeError`が発生します。

`"hi" * 5`のように順番を入れ替えた場合、結果は`"hihihihihi"`になることに注意してください。これは`String`自体に`*`演算子が定義されていて、文字列が左辺の場合に使用されるためです。

---------------------------------------------------------------------------

